![.NET Core](https://github.com/Tornfeldt/GatewayAPI/workflows/Build%20&%20deploy/badge.svg?branch=master)
<br/>
![Nuget (with prereleases)](https://img.shields.io/nuget/vpre/Pebtos.GatewayApi.Core?label=NuGet%20Pebtos.GatewayApi.Core)
<br/>
![Nuget (with prereleases)](https://img.shields.io/nuget/vpre/Pebtos.GatewayApi.Rest?label=NuGet%20Pebtos.GatewayApi.Rest)

# GatewayAPI
API handler for SMS gateway GatewayAPI.

# Table of contents

- [GatewayAPI](#gatewayapi)
- [Table of contents](#table-of-contents)
- [Introduction](#introduction)
- [Caveats](#caveats)
- [Installation](#installation)
- [Usage](#usage)
  - [Sending SMS](#sending-sms)
  - [Receiving message status](#receiving-message-status)


# Introduction
This project is an API handler or API wrapper of the SMS gateway GatewayAPI.com.
This project is not developed by GatewayAPI.com, but was made by me because I needed a simple reusable wrapper.

If you want to use this wrapper, then go to GatewayAPI.com, create an account, buy some credit and find your private API token.

Documentation used when creating this wrapper can be found here: https://gatewayapi.com/docs

# Caveats
This is very much an alpha release and there might be things that do not work...

Not all functionality has been implemented. Here is some of the things which has not implemented:
* Tags when sending SMS
* Overcharged SMS
* Get SMS status (you can parse the webhook response instead)
* Delete scheduled SMS
* Check account balance
* Get prices

# Installation
Install NuGet package [Pebtos.GatewayApi](https://www.nuget.org/packages/Pebtos.GatewayApi/)

# Usage
## Sending SMS
First we need to create a recipient of the SMS we want to send.

```C#
var recipientPhoneNumberString = "+4529641389";
var recipientPhoneNumber = PhoneNumber.Create(recipientPhoneNumberString);
var recipient = new Recipient
{
    PhoneNumber = recipientPhoneNumber
};
```

When creating a `PhoneNumber`, then it must include the country prefix. If we use Denmark as an example, you can use `+45`, `0045` or `45` as a prefix. The phone number is not valid without the prefix.

Now we create the sender.

```C#
var senderPhoneNumberString = "+4529641388";
var senderPhoneNumber = PhoneNumber.Create(senderPhoneNumberString);
var sender = new PhoneNumberMessageSender(senderPhoneNumber);
```

Here we use a valid phone number as the sender, but we could have used a text instead:

```C#
var sender = new StringMessageSender("FromMe");
```

Now we can create the message:
```C#
var message = new Message
{
    MessageContent = "Hello world by SMS!",
    Sender = sender,
    Recipients = new[] { recipient }
};
```

`Message` contains a lot of properties which is described in the XML comments. For more information go to the [API documentation](https://gatewayapi.com/docs).

Now we need to initialize the API handler:

```C#
var options = new ApiSettings
{
    ApiToken = "INSERT_YOUR_TOKEN_HERE"
};
var apiHandler = new ApiHandler(options);
```

You can choose to create a handler for for every request or use it as a singleton -- the functions on `ApiHandler` are thread safe.

Now we just have to send the SMS:
```C#
var response = await apiHandler.SendMessageAsync(message);
```

The response contains a unique ID generated by the API, which can be used later when either polling for SMS status (not recommended) or when the API sends message updates to you using a webhook (recommended).


## Receiving message status
Before you can receive message statusses you must either set `CallbackUrl` when sending a `Message` or set an address for the webhook in the GatewayAPI administration.

Now you can receive message statusses like this: (this is an example using ASP.NET Core 3.1, but the principle holds for other frameworks as well; get the request body and deserialize it)
```C#
[HttpPost("messageStatus")]
public async Task<IActionResult> MessageStatus()
{
    using var reader = new StreamReader(Request.Body, Encoding.UTF8);
    var content = await reader.ReadToEndAsync();
    
    var messageStatus = MessageStatus.Deserialize(content);

    // Do stuff like matching sent messages with either messageStatus.MessageId or messageStatus.UserReference and messageStatus.Recipient

    return Ok();
}
```

If you are using ASP.NET Core 3.1, then you can make the framework deserialize the message status directly like this:
```C#
[HttpPost("messageStatus")]
public async Task<IActionResult> MessageStatus([FromBody] MessageStatus messageStatus)
{
    // Do stuff like matching sent messages with either messageStatus.MessageId or messageStatus.UserReference and messageStatus.Recipient

    return Ok();
}
```